package de.julielab.concepts.db;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.apache.commons.configuration2.HierarchicalConfiguration;
import org.apache.commons.configuration2.tree.ImmutableNode;
import org.neo4j.graphdb.Node;
import org.neo4j.graphdb.Transaction;
import org.neo4j.shell.util.json.JSONException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.gson.Gson;
import com.google.gson.JsonSerializer;

import de.julielab.bioportal.ontologies.data.OntologyClass;
import de.julielab.bioportal.util.BioPortalToolUtils;
import de.julielab.concepts.util.ConceptCreationException;
import de.julielab.concepts.util.ConceptInsertionException;
import de.julielab.java.utilities.FileUtilities;
import de.julielab.neo4j.plugins.ConceptManager;
import de.julielab.neo4j.plugins.FacetManager.FacetLabel;
import de.julielab.neo4j.plugins.datarepresentation.ConceptCoordinates;
import de.julielab.neo4j.plugins.datarepresentation.ImportConcept;
import de.julielab.neo4j.plugins.datarepresentation.ImportConcepts;
import de.julielab.neo4j.plugins.datarepresentation.ImportFacet;
import de.julielab.neo4j.plugins.datarepresentation.ImportFacetGroup;
import de.julielab.neo4j.plugins.datarepresentation.constants.FacetConstants;

/**
 * <p>
 * Creates {@link ImportConcept} instances from the ontology class output
 * created by the julielab-bioportal-ontology-tools.
 * </p>
 * <p>
 * This class reads a specific JSON format as it is generated by the
 * julielab-bioportal-ontology-tools. The JSON format is centered around the
 * human-readable names of ontology classes and their taxonomical structure. For
 * more information, refer to the link given below.
 * </p>
 * 
 * @author faessler
 * @see https://github.com/JULIELab/julielab-bioportal-ontology-tools
 */
public class JulielabBioPortalToolsConceptCreator implements ConceptCreator {

	private static final Logger log = LoggerFactory.getLogger(JulielabBioPortalToolsConceptCreator.class);

	/**
	 * A file or directory pointing to the JSON file(s) containing the extracted
	 * names of ontology classes. The JSON format is required to match the
	 * definition of the julielab-bioportal-ontology-tools.
	 */
	public static final String CONFKEY_ONTOLOGY_CLASS_NAMES = "path";
	/**
	 * In the Neo4j database, concepts are grouped in facets and facets are grouped
	 * into facet groups. This is the unique name of the facet group the currently
	 * inserted facet should go to.
	 */
	public static final String CONFKEY_FACET_GROUP_NAME = "facetgroupname";
	
	@Override
	public Stream<ImportConcepts> createConcepts(HierarchicalConfiguration<ImmutableNode> config) throws ConceptCreationException {
		// First, read the configuration.
		String facetGroupName = config.getString(CONFKEY_FACET_GROUP_NAME);
		File ontologyNamesPath = new File(config.getString(CONFKEY_ONTOLOGY_CLASS_NAMES));

		Gson gson = new Gson();
		File[] ontologyNameFiles;
		if (ontologyNamesPath.isDirectory())
			ontologyNameFiles = ontologyNamesPath
					.listFiles((f, n) -> n.endsWith(".jsonlst") || n.endsWith(".jsonlst.gz"));
		else
			ontologyNameFiles = new File[] { ontologyNamesPath };

		log.info("Reading {} ontology class files for concept creation.", ontologyNameFiles.length);
		ImportConcepts importConcepts = null;
		try {
			for (int i = 0; i < ontologyNameFiles.length; i++) {
				File f = ontologyNameFiles[i];
				String acronym = BioPortalToolUtils.getAcronymFromFileName(f);

				// The format of the name files is one class per line as
				// a JSON object on its own. We will now build a JSON
				// array out of all the classes
				// of the file
				BufferedReader br = FileUtilities.getReaderFromFile(f);
				// Convert the JSON lines to OntologyClass objects
				Stream<OntologyClass> classStream = br.lines().map(l -> gson.fromJson(l, OntologyClass.class));
				// Convert the OntologyClass objects to ImportConcepts
				Stream<ImportConcept> conceptStream = classStream.map(c -> {
					List<ConceptCoordinates> parentCoordinates = Collections.emptyList();
					if (c.parents != null && c.parents.parents != null)
						parentCoordinates = c.parents.parents.stream().map(p -> new ConceptCoordinates(p, acronym, true))
								.collect(Collectors.toList());
					return new ImportConcept(c.prefLabel, c.synonym.synonyms, c.definition,
							new ConceptCoordinates(c.id, acronym, true), parentCoordinates);
				});
				// Note: Facet groups are unique by name in the database (the
				// ConceptManager that does the concept insertion makes sure of it).
				ImportFacetGroup fg = new ImportFacetGroup(facetGroupName);
				ImportFacet facet = new ImportFacet(fg, BioPortalToolUtils.getAcronymFromFileName(f), BioPortalToolUtils.getAcronymFromFileName(f),
						BioPortalToolUtils.getAcronymFromFileName(f), FacetConstants.SRC_TYPE_HIERARCHICAL);

			}
		} catch (IOException e) {
			throw new ConceptCreationException(e);
		}
		return null;
	}

}
